# Algorand PyTeal Smart Contracts A comprehensive guide to Algorand smart contract development using PyTeal, demonstrating the unique features and advantages of the Algorand blockchain. ## What You'll Learn - PyTeal Programming: Algorand's Python-based smart contract language - Application State: Global and local state management - Atomic Transactions: Algorand's unique transaction composability - Pure Proof of Stake: Understanding Algorand's consensus mechanism - Ultra-Low Fees: Cost-effective blockchain operations - Instant Finality: 4.5-second transaction finality - Carbon Negative: Environmentally sustainable blockchain ## Algorand Advantages ### Performance - 4.5 second finality (vs 12+ minutes Bitcoin) - 10,000+ TPS theoretical throughput - $0.001 transaction fees (vs $20+ Ethereum) ### Security - Pure Proof of Stake consensus - Immediate finality (no reorganizations) - Cryptographic sortition for validator selection ### Sustainability - Carbon negative blockchain - Minimal energy consumption - Sustainable by design ### Developer Experience - PyTeal - Python-based smart contracts - Rich standard library for common operations - Atomic transactions - compose complex operations - Built-in asset creation (ASA - Algorand Standard Assets) ## Prerequisites - Python 3.7+ - Basic Python knowledge - Understanding of blockchain concepts - Algorand account with TestNet ALGO ## Setup Instructions ### 1. Install Dependencies ```bash cd algorand-pyteal pip install -r requirements.txt ``` ### 2. Compile Smart Contracts ```bash python simple_counter.py ``` This generates: - `counter_approval.teal` - Main contract logic - `counter_clear.teal` - Clear state program - `counter_advanced_approval.teal` - Advanced features ### 3. Get TestNet ALGO ```bash # Generate test account and get funding info python client.py fund ``` Visit the TestNet dispenser: https://testnet.algoexplorer.io/dispenser ### 4. Run Demo ```bash python client.py ``` ## Project Structure ``` algorand-pyteal/ simple_counter.py # Main PyTeal contract client.py # Python client for interaction requirements.txt # Python dependencies counter_approval.teal # Compiled approval program counter_clear.teal # Compiled clear state program README.md # This file ``` ## Smart Contract Features ### Basic Counter Contract #### Global State Variables ```python App.globalPut(Bytes("counter"), Int(0)) # Main counter value App.globalPut(Bytes("creator"), Txn.sender()) # Contract creator App.globalPut(Bytes("total_increments"), Int(0)) # Statistics tracking App.globalPut(Bytes("total_decrements"), Int(0)) # Statistics tracking ``` #### Core Methods ```python # Increment counter with overflow protection on_increment = Seq([ Assert(App.globalGet(Bytes("counter")) < Int(1000000)), App.globalPut(Bytes("counter"), App.globalGet(Bytes("counter")) + Int(1)), Return(Int(1)) ]) # Decrement with underflow protection on_decrement = Seq([ Assert(App.globalGet(Bytes("counter")) > Int(0)), App.globalPut(Bytes("counter"), App.globalGet(Bytes("counter")) - Int(1)), Return(Int(1)) ]) # Reset (creator only) on_reset = Seq([ Assert(Txn.sender() == App.globalGet(Bytes("creator"))), App.globalPut(Bytes("counter"), Int(0)), Return(Int(1)) ]) ``` ### Advanced Features #### Time-Based Restrictions ```python # Prevent spam by enforcing minimum time between operations Assert( Global.latest_timestamp() > App.localGet(Txn.sender(), Bytes("last_operation")) + App.globalGet(Bytes("min_time_between_updates")) ) ``` #### User Registration System ```python # Opt-in mechanism for user-specific counters on_opt_in = Seq([ App.localPut(Txn.sender(), Bytes("personal_counter"), Int(0)), App.localPut(Txn.sender(), Bytes("joined_timestamp"), Global.latest_timestamp()), Return(Int(1)) ]) ``` ## Client Interaction ### Setup Client ```python from algosdk.v2client import algod from client import AlgorandCounterClient # Connect to TestNet algod_client = algod.AlgodClient("", "https://testnet-api.algonode.cloud") client = AlgorandCounterClient(algod_client) ``` ### Deploy Contract ```python # Load compiled TEAL code with open('counter_approval.teal', 'r') as f: approval_teal = f.read() with open('counter_clear.teal', 'r') as f: clear_teal = f.read() # Create application on Algorand app_id = client.create_app(approval_teal, clear_teal) ``` ### Interact with Contract ```python # Increment counter client.increment_counter() # Decrement counter client.decrement_counter() # Read current state state = client.read_global_state() print(f"Counter value: {state['counter']}") ``` ## Key PyTeal Concepts ### 1. Expressions vs Statements ```python # Expression (returns value) counter_value = App.globalGet(Bytes("counter")) # Statement (performs action) App.globalPut(Bytes("counter"), Int(0)) ``` ### 2. Conditional Logic ```python program = Cond( [condition1, action1], [condition2, action2], [Int(1) == Int(1), default_action] # Default case ) ``` ### 3. State Management ```python # Global state (shared across all users) App.globalGet(Bytes("key")) App.globalPut(Bytes("key"), value) # Local state (per-user) App.localGet(account, Bytes("key")) App.localPut(account, Bytes("key"), value) ``` ### 4. Security Assertions ```python # Verify conditions before execution Assert(condition) # Fails transaction if false # Access control Assert(Txn.sender() == App.globalGet(Bytes("owner"))) ``` ## Algorand vs Other Blockchains | Feature | Algorand | Ethereum | Solana | Bitcoin | |---------|----------|----------|---------|---------| | Consensus | Pure PoS | PoS | PoH + PoS | PoW | | Finality | 4.5 seconds | 6+ minutes | 400ms | 60+ minutes | | TPS | 10,000+ | 15 | 65,000 | 7 | | Fees | ~$0.001 | $5-50+ | ~$0.0025 | $5-50+ | | Energy | Minimal | High | Moderate | Very High | | Language | PyTeal/TEAL | Solidity | Rust | Script | ## Real-World Applications ### DeFi Protocols - Tinyman: Algorand's leading DEX - Algofi: Lending and borrowing - Folks Finance: Multi-chain DeFi ### NFT Marketplaces - Rand Gallery: Algorand NFT platform - AlgoGems: Gaming NFTs - AB2 Gallery: Art NFTs ### Enterprise Solutions - CBDC: Central Bank Digital Currencies - Supply Chain: Transparency and tracking - Identity: Self-sovereign identity solutions ## Advanced Development Patterns ### 1. Atomic Transactions ```python # Compose multiple operations atomically from algosdk.future.transaction import assign_group_id # Create transaction group txn1 = PaymentTxn(...) # Send ALGO txn2 = ApplicationCallTxn(...) # Call smart contract txn3 = AssetTransferTxn(...) # Transfer ASA # Group transactions (all succeed or all fail) group_txns = [txn1, txn2, txn3] assign_group_id(group_txns) ``` ### 2. ASA (Algorand Standard Assets) ```python # Create custom token create_txn = AssetConfigTxn( sender=creator_address, sp=params, total=1000000, # Total supply default_frozen=False, unit_name="LEARN", asset_name="LearnToken", manager=creator_address, reserve=creator_address, freeze=creator_address, clawback=creator_address, decimals=6 ) ``` ### 3. Inner Transactions ```python # Smart contract can create transactions InnerTxnBuilder.Begin() InnerTxnBuilder.SetFields({ TxnField.type_enum: TxnType.Payment, TxnField.receiver: Txn.sender(), TxnField.amount: Int(1000000), # 1 ALGO reward }) InnerTxnBuilder.Submit() ``` ## Testing and Debugging ### Unit Testing ```python import pytest from pyteal import * def test_counter_increment(): # Test increment logic program = approval_program() # ... test implementation ``` ### TEAL Debugger ```bash # Use tealdbg for step-by-step debugging tealdbg debug counter_approval.teal -d dryrun_response.json ``` ## Gas/Fee Optimization ### Algorand Fee Structure - Flat fee: 0.001 ALGO per transaction - No gas wars: Predictable costs - Asset operations: Same low fee - Smart contracts: Same low fee ### Optimization Tips 1. Minimize state operations: Each state change costs the same 2. Use local state when possible: More efficient for user data 3. Batch operations: Group related transactions 4. Optimize TEAL size: Smaller programs = faster execution ## Deployment to MainNet ### 1. Get MainNet ALGO ```python # Production client setup algod_client = algod.AlgodClient( "your-api-key", "https://mainnet-api.algonode.cloud" ) ``` ### 2. Production Considerations - Audit smart contracts thoroughly - Test on TestNet extensively - Use hardware wallets for MainNet - Monitor application after deployment ## Additional Resources - [Algorand Developer Portal](https://developer.algorand.org/) - [PyTeal Documentation](https://pyteal.readthedocs.io/) - [Algorand SDK Documentation](https://py-algorand-sdk.readthedocs.io/) - [AlgoExplorer](https://algoexplorer.io/) - Blockchain explorer - [Algorand Dispenser](https://dispenser.testnet.aws.algodev.network/) - TestNet funding ## Job-Ready Skills Covered - PyTeal smart contract development - Algorand SDK integration - State management (global/local) - Transaction composition and atomic swaps - Security best practices and assertions - Cost-effective blockchain development - Sustainable blockchain technology - High-performance blockchain applications  Master Algorand development for the next generation of efficient, sustainable blockchain applications!